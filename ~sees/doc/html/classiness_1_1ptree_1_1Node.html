<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>sees: iness::ptree::Node Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">sees
   &#160;<span id="projectnumber">1.2.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceiness.html">iness</a></li><li class="navelem"><b>ptree</b></li><li class="navelem"><a class="el" href="classiness_1_1ptree_1_1Node.html">Node</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classiness_1_1ptree_1_1Node-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">iness::ptree::Node Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Main class of our parameter tree functionality. It defines the main interfaces and provides the functionality to build up and iterate through parameter trees. Every node in the tree is derived from it.  
 <a href="classiness_1_1ptree_1_1Node.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="node_8hpp_source.html">node.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for iness::ptree::Node:</div>
<div class="dyncontent">
<div class="center"><img src="classiness_1_1ptree_1_1Node__inherit__graph.png" border="0" usemap="#iness_1_1ptree_1_1Node_inherit__map" alt="Inheritance graph"/></div>
<map name="iness_1_1ptree_1_1Node_inherit__map" id="iness_1_1ptree_1_1Node_inherit__map">
<area shape="rect" id="node3" href="classiness_1_1ptree_1_1SimpleBase.html" title="iness::ptree::SimpleBase" alt="" coords="7,169,175,196"/>
<area shape="rect" id="node4" href="classiness_1_1ptree_1_1Simple.html" title="iness::ptree::Simple\l\&lt; T_TYPE \&gt;" alt="" coords="21,244,160,285"/>
<area shape="rect" id="node5" href="classiness_1_1ptree_1_1SimpleValue.html" title="Template definition for a simple parameter tree node that holds its own value. " alt="" coords="5,333,176,375"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for iness::ptree::Node:</div>
<div class="dyncontent">
<div class="center"><img src="classiness_1_1ptree_1_1Node__coll__graph.png" border="0" usemap="#iness_1_1ptree_1_1Node_coll__map" alt="Collaboration graph"/></div>
<map name="iness_1_1ptree_1_1Node_coll__map" id="iness_1_1ptree_1_1Node_coll__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa34c11f057873f6e7f579a610dfdc2bd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiness_1_1ptree_1_1Node.html#aa34c11f057873f6e7f579a610dfdc2bd">Type</a> { <a class="el" href="classiness_1_1ptree_1_1Node.html#aa34c11f057873f6e7f579a610dfdc2bda6222ba386bcc675dab6063afba7235f1">Type::FANCY</a>, 
<a class="el" href="classiness_1_1ptree_1_1Node.html#aa34c11f057873f6e7f579a610dfdc2bdae5564829e2f85f6a6873a9d5c4f26d09">Type::SIMPLE</a>, 
<a class="el" href="classiness_1_1ptree_1_1Node.html#aa34c11f057873f6e7f579a610dfdc2bda87752381b583740610f1dfeb07fdad7e">Type::VECTOR</a>
 }<tr class="memdesc:aa34c11f057873f6e7f579a610dfdc2bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to provide type information to figure out at runtime to which type a cast is possible.  <a href="classiness_1_1ptree_1_1Node.html#aa34c11f057873f6e7f579a610dfdc2bd">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aa34c11f057873f6e7f579a610dfdc2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a934d5d90e4a0a4b7c11774719641e90f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiness_1_1ptree_1_1Node.html#a934d5d90e4a0a4b7c11774719641e90f">RwType</a> { <a class="el" href="classiness_1_1ptree_1_1Node.html#a934d5d90e4a0a4b7c11774719641e90faf1bfc7bafe89bca7f7e2a7a40ebdc7c2">RwType::READ_AND_WRITE</a>, 
<a class="el" href="classiness_1_1ptree_1_1Node.html#a934d5d90e4a0a4b7c11774719641e90fa47c7e7cb36a953a8c47e02000036bb44">RwType::READ_ONLY</a>, 
<a class="el" href="classiness_1_1ptree_1_1Node.html#a934d5d90e4a0a4b7c11774719641e90fad8fddf06187e680ab5a6355f76a17357">RwType::WRITE_ONLY</a>
 }<tr class="memdesc:a934d5d90e4a0a4b7c11774719641e90f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the read/write capabilites the parameter supports.  <a href="classiness_1_1ptree_1_1Node.html#a934d5d90e4a0a4b7c11774719641e90f">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a934d5d90e4a0a4b7c11774719641e90f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67b3b41925661ff8304c2be017dd3d2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiness_1_1ptree_1_1Node.html#ae67b3b41925661ff8304c2be017dd3d2">ReadState</a> { <a class="el" href="classiness_1_1ptree_1_1Node.html#ae67b3b41925661ff8304c2be017dd3d2add1dab546c7769f17e9d4e8e4f2f1bf4">ReadState::SUCCESSFUL</a> = 0, 
<a class="el" href="classiness_1_1ptree_1_1Node.html#ae67b3b41925661ff8304c2be017dd3d2a4be6a75b35e47c01bca1a18f1b0ce3fb">ReadState::STALLED</a> =1, 
<a class="el" href="classiness_1_1ptree_1_1Node.html#ae67b3b41925661ff8304c2be017dd3d2ab9e14d9b2886bcff408b85aefa780419">ReadState::FAILED</a> = 2, 
<a class="el" href="classiness_1_1ptree_1_1Node.html#ae67b3b41925661ff8304c2be017dd3d2a40aa75f8e8cfdf7b660c5620e953229f">ReadState::UNSUPPORTED</a> = 3
 }<tr class="memdesc:ae67b3b41925661ff8304c2be017dd3d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides state information about reading.  <a href="classiness_1_1ptree_1_1Node.html#ae67b3b41925661ff8304c2be017dd3d2">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ae67b3b41925661ff8304c2be017dd3d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61e1d8b83a9ad7cae3f9dec04d1fc1a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiness_1_1ptree_1_1Node.html#ae61e1d8b83a9ad7cae3f9dec04d1fc1a">WriteState</a> { <a class="el" href="classiness_1_1ptree_1_1Node.html#ae61e1d8b83a9ad7cae3f9dec04d1fc1aadd1dab546c7769f17e9d4e8e4f2f1bf4">WriteState::SUCCESSFUL</a> = 0, 
<a class="el" href="classiness_1_1ptree_1_1Node.html#ae61e1d8b83a9ad7cae3f9dec04d1fc1aa4be6a75b35e47c01bca1a18f1b0ce3fb">WriteState::STALLED</a> = 1, 
<a class="el" href="classiness_1_1ptree_1_1Node.html#ae61e1d8b83a9ad7cae3f9dec04d1fc1aab9e14d9b2886bcff408b85aefa780419">WriteState::FAILED</a> = 2, 
<a class="el" href="classiness_1_1ptree_1_1Node.html#ae61e1d8b83a9ad7cae3f9dec04d1fc1aa40aa75f8e8cfdf7b660c5620e953229f">WriteState::UNSUPPORTED</a> = 3
 }<tr class="memdesc:ae61e1d8b83a9ad7cae3f9dec04d1fc1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides state information about writing.  <a href="classiness_1_1ptree_1_1Node.html#ae61e1d8b83a9ad7cae3f9dec04d1fc1a">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ae61e1d8b83a9ad7cae3f9dec04d1fc1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538b89bd2c538cecca08ec1ccfe672be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a538b89bd2c538cecca08ec1ccfe672be"></a>
typedef std::shared_ptr&lt; <a class="el" href="classiness_1_1ptree_1_1Node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Ptr</b></td></tr>
<tr class="separator:a538b89bd2c538cecca08ec1ccfe672be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a752a3fc83dfd7a8fa34fafcae45fda19"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a752a3fc83dfd7a8fa34fafcae45fda19"></a>
typedef std::shared_ptr&lt; const <a class="el" href="classiness_1_1ptree_1_1Node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ConstPtr</b></td></tr>
<tr class="separator:a752a3fc83dfd7a8fa34fafcae45fda19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f8c2532684fd9d8685cc157328a296"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22f8c2532684fd9d8685cc157328a296"></a>
typedef <a class="el" href="classiness_1_1util_1_1StdMapIterator.html">util::StdMapIterator</a>&lt; std::map&lt; unsigned int, Ptr &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Iterator</b></td></tr>
<tr class="separator:a22f8c2532684fd9d8685cc157328a296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43940b3c308ca7b8c558d187547ae1d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43940b3c308ca7b8c558d187547ae1d2"></a>
typedef <a class="el" href="classiness_1_1util_1_1ConstStdMapIterator.html">util::ConstStdMapIterator</a>&lt; std::map&lt; unsigned int, Ptr &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ConstIterator</b></td></tr>
<tr class="separator:a43940b3c308ca7b8c558d187547ae1d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:addd1a14b9a891ba1b12f540e6d606556"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="addd1a14b9a891ba1b12f540e6d606556"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiness_1_1ptree_1_1Node.html#addd1a14b9a891ba1b12f540e6d606556">Node</a> (<a class="el" href="classiness_1_1ptree_1_1Node.html#a934d5d90e4a0a4b7c11774719641e90f">RwType</a> _rw_type=<a class="el" href="classiness_1_1ptree_1_1Node.html#a934d5d90e4a0a4b7c11774719641e90faf1bfc7bafe89bca7f7e2a7a40ebdc7c2">RwType::READ_AND_WRITE</a>)</td></tr>
<tr class="memdesc:addd1a14b9a891ba1b12f540e6d606556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:addd1a14b9a891ba1b12f540e6d606556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aba3eb8c37340e5bc33a58f3e42f389"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0aba3eb8c37340e5bc33a58f3e42f389"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiness_1_1ptree_1_1Node.html#a0aba3eb8c37340e5bc33a58f3e42f389">Node</a> (const <a class="el" href="classiness_1_1ptree_1_1Node.html">Node</a> &amp;)</td></tr>
<tr class="memdesc:a0aba3eb8c37340e5bc33a58f3e42f389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="separator:a0aba3eb8c37340e5bc33a58f3e42f389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca5666891dd68c6f41329555d9e7523"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acca5666891dd68c6f41329555d9e7523"></a>
<a class="el" href="classiness_1_1ptree_1_1Node.html">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiness_1_1ptree_1_1Node.html#acca5666891dd68c6f41329555d9e7523">operator=</a> (const <a class="el" href="classiness_1_1ptree_1_1Node.html">Node</a> &amp;)</td></tr>
<tr class="memdesc:acca5666891dd68c6f41329555d9e7523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. <br /></td></tr>
<tr class="separator:acca5666891dd68c6f41329555d9e7523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a8a772a29a59380a6e0b98e2be42545"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a8a772a29a59380a6e0b98e2be42545"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiness_1_1ptree_1_1Node.html#a6a8a772a29a59380a6e0b98e2be42545">~Node</a> ()</td></tr>
<tr class="memdesc:a6a8a772a29a59380a6e0b98e2be42545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a6a8a772a29a59380a6e0b98e2be42545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e1e432ffd5576dfbcc5998c062f8c9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a12e1e432ffd5576dfbcc5998c062f8c9"></a>
template&lt;typename T_TARGET_TYPE &gt; </td></tr>
<tr class="memitem:a12e1e432ffd5576dfbcc5998c062f8c9"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T_TARGET_TYPE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classiness_1_1ptree_1_1Node.html#a12e1e432ffd5576dfbcc5998c062f8c9">as</a> ()</td></tr>
<tr class="memdesc:a12e1e432ffd5576dfbcc5998c062f8c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts the node to the given type (The validity of the cast is only checked in debug mode). <br /></td></tr>
<tr class="separator:a12e1e432ffd5576dfbcc5998c062f8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7529cc4491da8ca0d3a4bdd9a35d5c66"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7529cc4491da8ca0d3a4bdd9a35d5c66"></a>
template&lt;typename T_TARGET_TYPE &gt; </td></tr>
<tr class="memitem:a7529cc4491da8ca0d3a4bdd9a35d5c66"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; const T_TARGET_TYPE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classiness_1_1ptree_1_1Node.html#a7529cc4491da8ca0d3a4bdd9a35d5c66">as</a> () const </td></tr>
<tr class="memdesc:a7529cc4491da8ca0d3a4bdd9a35d5c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts the node to the given type (The validity of the cast is only checked in debug mode). <br /></td></tr>
<tr class="separator:a7529cc4491da8ca0d3a4bdd9a35d5c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ceaef0111a8e1211917930a8bc742c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03ceaef0111a8e1211917930a8bc742c"></a>
<a class="el" href="classiness_1_1ptree_1_1Node.html">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiness_1_1ptree_1_1Node.html#a03ceaef0111a8e1211917930a8bc742c">operator[]</a> (std::string _key)</td></tr>
<tr class="memdesc:a03ceaef0111a8e1211917930a8bc742c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the member. If not yet existing, an entry of type <a class="el" href="classiness_1_1ptree_1_1Node.html" title="Main class of our parameter tree functionality. It defines the main interfaces and provides the funct...">Node</a> will be created and returned. <br /></td></tr>
<tr class="separator:a03ceaef0111a8e1211917930a8bc742c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8efdd0df4ca9e165a73a05d197beaf7d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8efdd0df4ca9e165a73a05d197beaf7d"></a>
Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiness_1_1ptree_1_1Node.html#a8efdd0df4ca9e165a73a05d197beaf7d">entry</a> (std::string _key)</td></tr>
<tr class="memdesc:a8efdd0df4ca9e165a73a05d197beaf7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the entry if it exists, a nullptr otherwise */. <br /></td></tr>
<tr class="separator:a8efdd0df4ca9e165a73a05d197beaf7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114a540714687469471473c9391d4ef7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a114a540714687469471473c9391d4ef7"></a>
ConstPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiness_1_1ptree_1_1Node.html#a114a540714687469471473c9391d4ef7">entry</a> (std::string _key) const </td></tr>
<tr class="memdesc:a114a540714687469471473c9391d4ef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the entry if it exists, a nullptr otherwise */. <br /></td></tr>
<tr class="separator:a114a540714687469471473c9391d4ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31dedeab6d915c519a52a7f7dd972a76"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31dedeab6d915c519a52a7f7dd972a76"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiness_1_1ptree_1_1Node.html#a31dedeab6d915c519a52a7f7dd972a76">hasEntry</a> (std::string _key) const </td></tr>
<tr class="memdesc:a31dedeab6d915c519a52a7f7dd972a76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether an entry exist. <br /></td></tr>
<tr class="separator:a31dedeab6d915c519a52a7f7dd972a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25176e713640f5e4f1e7fce0cbda0637"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25176e713640f5e4f1e7fce0cbda0637"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiness_1_1ptree_1_1Node.html#a25176e713640f5e4f1e7fce0cbda0637">addEntry</a> (std::string _key, Ptr _new_entry=<a class="el" href="namespaceiness.html#abacf50aa7067fefad614812c365b76d5">iness::make_shared</a>&lt; <a class="el" href="classiness_1_1ptree_1_1Node.html">Node</a> &gt;())</td></tr>
<tr class="memdesc:a25176e713640f5e4f1e7fce0cbda0637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new child parameter to the parameter: Returns true if successful. <br /></td></tr>
<tr class="separator:a25176e713640f5e4f1e7fce0cbda0637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1590d50c6dfafddec39d12648a3846b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1590d50c6dfafddec39d12648a3846b6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiness_1_1ptree_1_1Node.html#a1590d50c6dfafddec39d12648a3846b6">lockMapping</a> ()</td></tr>
<tr class="memdesc:a1590d50c6dfafddec39d12648a3846b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">After this call no new entries can be added to the node and all its childs. <br /></td></tr>
<tr class="separator:a1590d50c6dfafddec39d12648a3846b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f5e032f38aab370ac884d27bb186cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2f5e032f38aab370ac884d27bb186cc"></a>
virtual <a class="el" href="classiness_1_1ptree_1_1Node.html#aa34c11f057873f6e7f579a610dfdc2bd">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiness_1_1ptree_1_1Node.html#ad2f5e032f38aab370ac884d27bb186cc">type</a> () const </td></tr>
<tr class="memdesc:ad2f5e032f38aab370ac884d27bb186cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns information about the parameter type. <br /></td></tr>
<tr class="separator:ad2f5e032f38aab370ac884d27bb186cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a4681cc5c3d4ac8dea26977ce79af0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8a4681cc5c3d4ac8dea26977ce79af0"></a>
virtual <a class="el" href="classiness_1_1ptree_1_1Node.html#ae67b3b41925661ff8304c2be017dd3d2">ReadState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiness_1_1ptree_1_1Node.html#ae8a4681cc5c3d4ac8dea26977ce79af0">getReadState</a> () const </td></tr>
<tr class="memdesc:ae8a4681cc5c3d4ac8dea26977ce79af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current read state. <br /></td></tr>
<tr class="separator:ae8a4681cc5c3d4ac8dea26977ce79af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c259c89f609b0505e2016f6e2b6df8b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c259c89f609b0505e2016f6e2b6df8b"></a>
virtual <a class="el" href="classiness_1_1ptree_1_1Node.html#ae61e1d8b83a9ad7cae3f9dec04d1fc1a">WriteState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiness_1_1ptree_1_1Node.html#a6c259c89f609b0505e2016f6e2b6df8b">getWriteState</a> () const </td></tr>
<tr class="memdesc:a6c259c89f609b0505e2016f6e2b6df8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current write state. <br /></td></tr>
<tr class="separator:a6c259c89f609b0505e2016f6e2b6df8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974c018ceb300e105f4bfdc58d660291"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a974c018ceb300e105f4bfdc58d660291"></a>
virtual <a class="el" href="classiness_1_1ptree_1_1Node.html#ae61e1d8b83a9ad7cae3f9dec04d1fc1a">WriteState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiness_1_1ptree_1_1Node.html#a974c018ceb300e105f4bfdc58d660291">writeStalled</a> ()</td></tr>
<tr class="memdesc:a974c018ceb300e105f4bfdc58d660291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to write stalled data through for all childs, returns successful if all stalls were resolved. <br /></td></tr>
<tr class="separator:a974c018ceb300e105f4bfdc58d660291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982e9a89841f228c858a2d008f7e5b12"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a982e9a89841f228c858a2d008f7e5b12"></a>
virtual <a class="el" href="classiness_1_1ptree_1_1Node.html#ae67b3b41925661ff8304c2be017dd3d2">ReadState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiness_1_1ptree_1_1Node.html#a982e9a89841f228c858a2d008f7e5b12">readStalled</a> () const </td></tr>
<tr class="memdesc:a982e9a89841f228c858a2d008f7e5b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to read values of child nodes whose reading was stalled. <br /></td></tr>
<tr class="separator:a982e9a89841f228c858a2d008f7e5b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1efa14712f14a7a6358b712c7c02aab9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1efa14712f14a7a6358b712c7c02aab9"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiness_1_1ptree_1_1Node.html#a1efa14712f14a7a6358b712c7c02aab9">name</a> () const </td></tr>
<tr class="memdesc:a1efa14712f14a7a6358b712c7c02aab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the parameter name. <br /></td></tr>
<tr class="separator:a1efa14712f14a7a6358b712c7c02aab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c484309375c1840f3c6c899f3369fd"><td class="memItemLeft" align="right" valign="top">Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiness_1_1ptree_1_1Node.html#a48c484309375c1840f3c6c899f3369fd">properties</a> ()</td></tr>
<tr class="memdesc:a48c484309375c1840f3c6c899f3369fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns additional properties of the parameter.  <a href="#a48c484309375c1840f3c6c899f3369fd">More...</a><br /></td></tr>
<tr class="separator:a48c484309375c1840f3c6c899f3369fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18358b96a28af392e5c17d14ce6b6f65"><td class="memTemplParams" colspan="2">template&lt;typename T_INFO_TYPE &gt; </td></tr>
<tr class="memitem:a18358b96a28af392e5c17d14ce6b6f65"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classiness_1_1ptree_1_1Node.html#a18358b96a28af392e5c17d14ce6b6f65">addPropertyEntry</a> (std::string _name, T_INFO_TYPE _info_element)</td></tr>
<tr class="memdesc:a18358b96a28af392e5c17d14ce6b6f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a property to the tree's first level (convenience function)  <a href="#a18358b96a28af392e5c17d14ce6b6f65">More...</a><br /></td></tr>
<tr class="separator:a18358b96a28af392e5c17d14ce6b6f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e8254812f73e5bfcb7a71087e64d6f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35e8254812f73e5bfcb7a71087e64d6f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiness_1_1ptree_1_1Node.html#a35e8254812f73e5bfcb7a71087e64d6f">hasPropertyEntry</a> (std::string _name) const </td></tr>
<tr class="memdesc:a35e8254812f73e5bfcb7a71087e64d6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to check if a property entry exists. <br /></td></tr>
<tr class="separator:a35e8254812f73e5bfcb7a71087e64d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0dfa472335d13afe63441f8d9dc21a3"><td class="memTemplParams" colspan="2">template&lt;typename T_INFO_TYPE &gt; </td></tr>
<tr class="memitem:ad0dfa472335d13afe63441f8d9dc21a3"><td class="memTemplItemLeft" align="right" valign="top">T_INFO_TYPE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classiness_1_1ptree_1_1Node.html#ad0dfa472335d13afe63441f8d9dc21a3">getPropertyEntry</a> (std::string _name) const </td></tr>
<tr class="memdesc:ad0dfa472335d13afe63441f8d9dc21a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to retrieve property entries of known type.  <a href="#ad0dfa472335d13afe63441f8d9dc21a3">More...</a><br /></td></tr>
<tr class="separator:ad0dfa472335d13afe63441f8d9dc21a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1507df228486b0a03e87107f26794279"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1507df228486b0a03e87107f26794279"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiness_1_1ptree_1_1Node.html#a1507df228486b0a03e87107f26794279">nrOfChildNodes</a> () const </td></tr>
<tr class="memdesc:a1507df228486b0a03e87107f26794279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of child nodes. <br /></td></tr>
<tr class="separator:a1507df228486b0a03e87107f26794279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a921adc2c25decc3fa9f7e75190d27e67"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a921adc2c25decc3fa9f7e75190d27e67"></a>
<a class="el" href="classiness_1_1util_1_1StdMapIterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiness_1_1ptree_1_1Node.html#a921adc2c25decc3fa9f7e75190d27e67">begin</a> ()</td></tr>
<tr class="memdesc:a921adc2c25decc3fa9f7e75190d27e67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator for child parameter nodes (ordered by creation time) <br /></td></tr>
<tr class="separator:a921adc2c25decc3fa9f7e75190d27e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394d3754578464d275db82f88e03a70f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a394d3754578464d275db82f88e03a70f"></a>
<a class="el" href="classiness_1_1util_1_1StdMapIterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiness_1_1ptree_1_1Node.html#a394d3754578464d275db82f88e03a70f">end</a> ()</td></tr>
<tr class="memdesc:a394d3754578464d275db82f88e03a70f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an end iterator for child parameter nodes (ordered by creation time) <br /></td></tr>
<tr class="separator:a394d3754578464d275db82f88e03a70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762e556ddd0217c909e82b7f2fd44fd0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a762e556ddd0217c909e82b7f2fd44fd0"></a>
<a class="el" href="classiness_1_1util_1_1ConstStdMapIterator.html">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiness_1_1ptree_1_1Node.html#a762e556ddd0217c909e82b7f2fd44fd0">begin</a> () const </td></tr>
<tr class="memdesc:a762e556ddd0217c909e82b7f2fd44fd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator for child parameter nodes (ordered by creation time) <br /></td></tr>
<tr class="separator:a762e556ddd0217c909e82b7f2fd44fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41fa245c56dc8e6e3b916e9d7e0d719b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41fa245c56dc8e6e3b916e9d7e0d719b"></a>
<a class="el" href="classiness_1_1util_1_1ConstStdMapIterator.html">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiness_1_1ptree_1_1Node.html#a41fa245c56dc8e6e3b916e9d7e0d719b">end</a> () const </td></tr>
<tr class="memdesc:a41fa245c56dc8e6e3b916e9d7e0d719b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const end iterator for child parameter nodes (ordered by creation time) <br /></td></tr>
<tr class="separator:a41fa245c56dc8e6e3b916e9d7e0d719b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bdeb73c4582c2d7385e56164e5dba7a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6bdeb73c4582c2d7385e56164e5dba7a"></a>
<a class="el" href="classiness_1_1ptree_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiness_1_1ptree_1_1Node.html#a6bdeb73c4582c2d7385e56164e5dba7a">parent</a> () const </td></tr>
<tr class="memdesc:a6bdeb73c4582c2d7385e56164e5dba7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parent accessor. <br /></td></tr>
<tr class="separator:a6bdeb73c4582c2d7385e56164e5dba7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a3085ad6001a0e4ea51acc90d35d68"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53a3085ad6001a0e4ea51acc90d35d68"></a>
<a class="el" href="classiness_1_1ptree_1_1Node.html#a934d5d90e4a0a4b7c11774719641e90f">RwType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiness_1_1ptree_1_1Node.html#a53a3085ad6001a0e4ea51acc90d35d68">rwType</a> () const </td></tr>
<tr class="memdesc:a53a3085ad6001a0e4ea51acc90d35d68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the read/write capabilities of the parameter. <br /></td></tr>
<tr class="separator:a53a3085ad6001a0e4ea51acc90d35d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747f106927fc9cc674792adc44382568"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a747f106927fc9cc674792adc44382568"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiness_1_1ptree_1_1Node.html#a747f106927fc9cc674792adc44382568">addOnChangeCallback</a> (std::function&lt; void()&gt; _func)</td></tr>
<tr class="memdesc:a747f106927fc9cc674792adc44382568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to add onChange callback function. <br /></td></tr>
<tr class="separator:a747f106927fc9cc674792adc44382568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad4d0fc26fc1e738f4e9150f6c518e47"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad4d0fc26fc1e738f4e9150f6c518e47"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiness_1_1ptree_1_1Node.html#aad4d0fc26fc1e738f4e9150f6c518e47">callOnChangeCallbacks</a> ()</td></tr>
<tr class="memdesc:aad4d0fc26fc1e738f4e9150f6c518e47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convencience function that calls all registered on change callback functions, if any. <br /></td></tr>
<tr class="separator:aad4d0fc26fc1e738f4e9150f6c518e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af77b45cc2fe56af6d639bdd2ecbad32c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af77b45cc2fe56af6d639bdd2ecbad32c"></a>
static Node::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiness_1_1ptree_1_1Node.html#af77b45cc2fe56af6d639bdd2ecbad32c">create</a> (<a class="el" href="classiness_1_1ptree_1_1Node.html#a934d5d90e4a0a4b7c11774719641e90f">RwType</a> _rw_type=<a class="el" href="classiness_1_1ptree_1_1Node.html#a934d5d90e4a0a4b7c11774719641e90faf1bfc7bafe89bca7f7e2a7a40ebdc7c2">RwType::READ_AND_WRITE</a>)</td></tr>
<tr class="memdesc:af77b45cc2fe56af6d639bdd2ecbad32c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory function for a Node::Ptr. <br /></td></tr>
<tr class="separator:af77b45cc2fe56af6d639bdd2ecbad32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ad99ecad514c0915677c70db669d76828"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad99ecad514c0915677c70db669d76828"></a>
<a class="el" href="classiness_1_1ptree_1_1Node.html#a934d5d90e4a0a4b7c11774719641e90f">RwType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiness_1_1ptree_1_1Node.html#ad99ecad514c0915677c70db669d76828">rwTypeRef</a> ()</td></tr>
<tr class="memdesc:ad99ecad514c0915677c70db669d76828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives childs access to alter the RwType. <br /></td></tr>
<tr class="separator:ad99ecad514c0915677c70db669d76828"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main class of our parameter tree functionality. It defines the main interfaces and provides the functionality to build up and iterate through parameter trees. Every node in the tree is derived from it. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="ae67b3b41925661ff8304c2be017dd3d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classiness_1_1ptree_1_1Node.html#ae67b3b41925661ff8304c2be017dd3d2">iness::ptree::Node::ReadState</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides state information about reading. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ae67b3b41925661ff8304c2be017dd3d2add1dab546c7769f17e9d4e8e4f2f1bf4"></a>SUCCESSFUL&#160;</td><td class="fielddoc">
<p>Reading was successful. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae67b3b41925661ff8304c2be017dd3d2a4be6a75b35e47c01bca1a18f1b0ce3fb"></a>STALLED&#160;</td><td class="fielddoc">
<p>The value that was attempted to be read couldn't be read on that level of the tree, instead the readStalled method of a parent node must be called. It is expected that if readStalled succeeded exactly one call to read will be successful (or fail) and that for a second call to read readStalled has to be called again. The first call after the last call to <a class="el" href="classiness_1_1ptree_1_1Node.html#a982e9a89841f228c858a2d008f7e5b12" title="Attempts to read values of child nodes whose reading was stalled. ">readStalled()</a> on the parent must never return STALLED. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae67b3b41925661ff8304c2be017dd3d2ab9e14d9b2886bcff408b85aefa780419"></a>FAILED&#160;</td><td class="fielddoc">
<p>Reading was not successful. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae67b3b41925661ff8304c2be017dd3d2a40aa75f8e8cfdf7b660c5620e953229f"></a>UNSUPPORTED&#160;</td><td class="fielddoc">
<p><a class="el" href="classiness_1_1ptree_1_1Node.html" title="Main class of our parameter tree functionality. It defines the main interfaces and provides the funct...">Node</a> doesn't support reading. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a934d5d90e4a0a4b7c11774719641e90f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classiness_1_1ptree_1_1Node.html#a934d5d90e4a0a4b7c11774719641e90f">iness::ptree::Node::RwType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates the read/write capabilites the parameter supports. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a934d5d90e4a0a4b7c11774719641e90faf1bfc7bafe89bca7f7e2a7a40ebdc7c2"></a>READ_AND_WRITE&#160;</td><td class="fielddoc">
<p>Parameter can be read and written. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a934d5d90e4a0a4b7c11774719641e90fa47c7e7cb36a953a8c47e02000036bb44"></a>READ_ONLY&#160;</td><td class="fielddoc">
<p>Parameter is read only. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a934d5d90e4a0a4b7c11774719641e90fad8fddf06187e680ab5a6355f76a17357"></a>WRITE_ONLY&#160;</td><td class="fielddoc">
<p>Parameter is write only. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="aa34c11f057873f6e7f579a610dfdc2bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classiness_1_1ptree_1_1Node.html#aa34c11f057873f6e7f579a610dfdc2bd">iness::ptree::Node::Type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to provide type information to figure out at runtime to which type a cast is possible. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="aa34c11f057873f6e7f579a610dfdc2bda6222ba386bcc675dab6063afba7235f1"></a>FANCY&#160;</td><td class="fielddoc">
<p>Everything but... </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aa34c11f057873f6e7f579a610dfdc2bdae5564829e2f85f6a6873a9d5c4f26d09"></a>SIMPLE&#160;</td><td class="fielddoc">
<p>Can be casted to <a class="el" href="classiness_1_1ptree_1_1SimpleBase.html">SimpleBase</a>. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aa34c11f057873f6e7f579a610dfdc2bda87752381b583740610f1dfeb07fdad7e"></a>VECTOR&#160;</td><td class="fielddoc">
<p>Can be casted to SimpleVectorBase. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ae61e1d8b83a9ad7cae3f9dec04d1fc1a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classiness_1_1ptree_1_1Node.html#ae61e1d8b83a9ad7cae3f9dec04d1fc1a">iness::ptree::Node::WriteState</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides state information about writing. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ae61e1d8b83a9ad7cae3f9dec04d1fc1aadd1dab546c7769f17e9d4e8e4f2f1bf4"></a>SUCCESSFUL&#160;</td><td class="fielddoc">
<p>Writing was successful. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae61e1d8b83a9ad7cae3f9dec04d1fc1aa4be6a75b35e47c01bca1a18f1b0ce3fb"></a>STALLED&#160;</td><td class="fielddoc">
<p>The value that was attempted to be written was not written through, but stalled along the way. To write it through, the writeStalled method likely needs to be called on a parent in the tree. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae61e1d8b83a9ad7cae3f9dec04d1fc1aab9e14d9b2886bcff408b85aefa780419"></a>FAILED&#160;</td><td class="fielddoc">
<p>Writing failed. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae61e1d8b83a9ad7cae3f9dec04d1fc1aa40aa75f8e8cfdf7b660c5620e953229f"></a>UNSUPPORTED&#160;</td><td class="fielddoc">
<p>Writing is not supported by the parameter. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a18358b96a28af392e5c17d14ce6b6f65"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_INFO_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool iness::ptree::Node::addPropertyEntry </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_INFO_TYPE&#160;</td>
          <td class="paramname"><em>_info_element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a property to the tree's first level (convenience function) </p>
<dl class="section return"><dt>Returns</dt><dd>True if property was successfully added </dd></dl>

</div>
</div>
<a class="anchor" id="ad0dfa472335d13afe63441f8d9dc21a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_INFO_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T_INFO_TYPE iness::ptree::Node::getPropertyEntry </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function to retrieve property entries of known type. </p>
<p>The existence of the entry is not checked, attempting to access a non existing entry will result in a runtime error. Use <a class="el" href="classiness_1_1ptree_1_1Node.html#a35e8254812f73e5bfcb7a71087e64d6f" title="Convenience function to check if a property entry exists. ">hasPropertyEntry()</a> to check its existence first. </p>

</div>
</div>
<a class="anchor" id="a48c484309375c1840f3c6c899f3369fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ptr iness::ptree::Node::properties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns additional properties of the parameter. </p>
<p>The following keys are defined and should be used according to the definition (Their existence is not mandatory though):</p><ul>
<li>Description [std::string] Describes in text what the parameter is.</li>
<li>NumberTextFormat [std::string] Can be used to define in what format a number is to be written to text. Defined choices: default, hexadecimal,</li>
<li>HexNumberBytes [unsigned int] Number of types used to display hex as hex number</li>
<li>SupportsOnChangeCallback [bool] If defined the parameter support the OnChangeCallback member</li>
<li>OnChangeCallback [std::vector&lt;std::function&lt;void()&gt;&gt;] Can be used to register functions that will be called after every write operation. Only supported if 'SupportsOnChangeCallback' is defined.</li>
<li>ReadableName [std::string] Short human readable name for the parameter, to be used on GUI's etc</li>
<li>Limits [ParameterNode] must have two childs : "Min" and "Max" [T_VALUE_TYPE] Defines allowed range for the parameter</li>
<li>StepSize [T_VALUE_TYPE] If GUI provides stepping functionality, this suggests a step size </li>
</ul>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>iness_common/util/parameter_tree/<a class="el" href="node_8hpp_source.html">node.hpp</a></li>
<li>iness_common/util/parameter_tree/impl/node.inl</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
